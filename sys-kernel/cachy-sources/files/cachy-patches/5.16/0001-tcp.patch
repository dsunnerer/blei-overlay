From 847f8d1ab8e386dc894830f9971c65bc8e909591 Mon Sep 17 00:00:00 2001
From: "P. Jung" <ptr1337@cachyos.org>
Date: Tue, 16 Nov 2021 19:03:07 +0000
Subject: [PATCH] tcp

Signed-off-by: P. Jung <ptr1337@cachyos.org>
---
 include/linux/skbuff.h |  2 ++
 include/net/sock.h     |  3 +++
 include/net/tcp.h      | 10 ++++++++++
 net/ipv4/tcp.c         |  5 ++++-
 net/ipv4/tcp.c.rej     | 38 ++++++++++++++++++++++++++++++++++++++
 net/ipv4/tcp_ipv4.c    |  1 +
 net/ipv6/tcp_ipv6.c    |  1 +
 7 files changed, 59 insertions(+), 1 deletion(-)
 create mode 100644 net/ipv4/tcp.c.rej

diff --git a/include/linux/skbuff.h b/include/linux/skbuff.h
index 841e2f0f5240..61feb80ca304 100644
--- a/include/linux/skbuff.h
+++ b/include/linux/skbuff.h
@@ -36,6 +36,7 @@
 #include <linux/splice.h>
 #include <linux/in6.h>
 #include <linux/if_packet.h>
+#include <linux/llist.h>
 #include <net/flow.h>
 #include <net/page_pool.h>
 #if IS_ENABLED(CONFIG_NF_CONNTRACK)
@@ -736,6 +737,7 @@ struct sk_buff {
 		};
 		struct rb_node		rbnode; /* used in netem, ip4 defrag, and tcp stack */
 		struct list_head	list;
+		struct llist_node	ll_node;
 	};
 
 	union {
diff --git a/include/net/sock.h b/include/net/sock.h
index 7b0c7f5aab67..87854d1a61bb 100644
--- a/include/net/sock.h
+++ b/include/net/sock.h
@@ -63,6 +63,7 @@
 #include <linux/indirect_call_wrapper.h>
 #include <linux/atomic.h>
 #include <linux/refcount.h>
+#include <linux/llist.h>
 #include <net/dst.h>
 #include <net/checksum.h>
 #include <net/tcp_states.h>
@@ -410,6 +411,8 @@ struct sock {
 		struct sk_buff	*head;
 		struct sk_buff	*tail;
 	} sk_backlog;
+	struct llist_head defer_list;
+
 #define sk_rmem_alloc sk_backlog.rmem_alloc
 
 	int			sk_forward_alloc;
diff --git a/include/net/tcp.h b/include/net/tcp.h
index 31d384c3778a..25c318a0b1d5 100644
--- a/include/net/tcp.h
+++ b/include/net/tcp.h
@@ -1352,6 +1352,16 @@ static inline bool tcp_checksum_complete(struct sk_buff *skb)
 }
 
 bool tcp_add_backlog(struct sock *sk, struct sk_buff *skb);
+
+void __sk_defer_free_flush(struct sock *sk);
+
+static inline void sk_defer_free_flush(struct sock *sk)
+{
+	if (llist_empty(&sk->defer_list))
+		return;
+	__sk_defer_free_flush(sk);
+}
+
 int tcp_filter(struct sock *sk, struct sk_buff *skb);
 void tcp_set_state(struct sock *sk, int state);
 void tcp_done(struct sock *sk);
diff --git a/net/ipv4/tcp.c b/net/ipv4/tcp.c
index 8affba5909bd..2305e8c6cb7f 100644
--- a/net/ipv4/tcp.c
+++ b/net/ipv4/tcp.c
@@ -2431,6 +2431,7 @@ static int tcp_recvmsg_locked(struct sock *sk, struct msghdr *msg, size_t len,
 			release_sock(sk);
 			lock_sock(sk);
 		} else {
+			sk_defer_free_flush(sk);
 			sk_wait_data(sk, &timeo, last);
 		}
 
@@ -2549,6 +2550,7 @@ int tcp_recvmsg(struct sock *sk, struct msghdr *msg, size_t len, int nonblock,
 	ret = tcp_recvmsg_locked(sk, msg, len, nonblock, flags, &tss,
 				 &cmsg_flags);
 	release_sock(sk);
+	sk_defer_free_flush(sk);
 
 	if (cmsg_flags && ret >= 0) {
 		if (cmsg_flags & TCP_CMSG_TS)
@@ -3083,7 +3085,7 @@ int tcp_disconnect(struct sock *sk, int flags)
 		sk->sk_frag.page = NULL;
 		sk->sk_frag.offset = 0;
 	}
-
+	sk_defer_free_flush(sk);
 	sk_error_report(sk);
 	return 0;
 }
@@ -4210,6 +4212,7 @@ static int do_tcp_getsockopt(struct sock *sk, int level,
 		err = BPF_CGROUP_RUN_PROG_GETSOCKOPT_KERN(sk, level, optname,
 							  &zc, &len, err);
 		release_sock(sk);
+		sk_defer_free_flush(sk);
 		if (len >= offsetofend(struct tcp_zerocopy_receive, msg_flags))
 			goto zerocopy_rcv_cmsg;
 		switch (len) {
diff --git a/net/ipv4/tcp.c.rej b/net/ipv4/tcp.c.rej
new file mode 100644
index 000000000000..9935dcbb6062
--- /dev/null
+++ b/net/ipv4/tcp.c.rej
@@ -0,0 +1,38 @@
+--- net/ipv4/tcp.c
++++ net/ipv4/tcp.c
+@@ -1580,14 +1580,34 @@ void tcp_cleanup_rbuf(struct sock *sk, int copied)
+ 		tcp_send_ack(sk);
+ }
+ 
++void __sk_defer_free_flush(struct sock *sk)
++{
++	struct llist_node *head;
++	struct sk_buff *skb, *n;
++
++	head = llist_del_all(&sk->defer_list);
++	llist_for_each_entry_safe(skb, n, head, ll_node) {
++		prefetch(n);
++		skb_mark_not_on_list(skb);
++		__kfree_skb(skb);
++	}
++}
++EXPORT_SYMBOL(__sk_defer_free_flush);
++
+ static void tcp_eat_recv_skb(struct sock *sk, struct sk_buff *skb)
+ {
++	__skb_unlink(skb, &sk->sk_receive_queue);
+ 	if (likely(skb->destructor == sock_rfree)) {
+ 		sock_rfree(skb);
+ 		skb->destructor = NULL;
+ 		skb->sk = NULL;
++		if (!skb_queue_empty(&sk->sk_receive_queue) ||
++		    !llist_empty(&sk->defer_list)) {
++			llist_add(&skb->ll_node, &sk->defer_list);
++			return;
++		}
+ 	}
+-	sk_eat_skb(sk, skb);
++	__kfree_skb(skb);
+ }
+ 
+ static struct sk_buff *tcp_recv_skb(struct sock *sk, u32 seq, u32 *off)
diff --git a/net/ipv4/tcp_ipv4.c b/net/ipv4/tcp_ipv4.c
index 5b8ce65dfc06..f53a85afeea6 100644
--- a/net/ipv4/tcp_ipv4.c
+++ b/net/ipv4/tcp_ipv4.c
@@ -2097,6 +2097,7 @@ int tcp_v4_rcv(struct sk_buff *skb)
 
 	sk_incoming_cpu_update(sk);
 
+	sk_defer_free_flush(sk);
 	bh_lock_sock_nested(sk);
 	tcp_segs_in(tcp_sk(sk), skb);
 	ret = 0;
diff --git a/net/ipv6/tcp_ipv6.c b/net/ipv6/tcp_ipv6.c
index b03dd02c9f13..9d8cf6df1d68 100644
--- a/net/ipv6/tcp_ipv6.c
+++ b/net/ipv6/tcp_ipv6.c
@@ -1753,6 +1753,7 @@ INDIRECT_CALLABLE_SCOPE int tcp_v6_rcv(struct sk_buff *skb)
 
 	sk_incoming_cpu_update(sk);
 
+	sk_defer_free_flush(sk);
 	bh_lock_sock_nested(sk);
 	tcp_segs_in(tcp_sk(sk), skb);
 	ret = 0;
-- 
2.34.0.rc2.16.g5a73c6bdc7

